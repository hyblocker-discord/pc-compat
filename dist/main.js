var __webpack_modules__={749:(__unused_webpack_module,exports)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getElectronBinding = void 0;\nconst getElectronBinding = (name) => {\n    if (process._linkedBinding) {\n        return process._linkedBinding('electron_common_' + name);\n    }\n    else if (process.electronBinding) {\n        return process.electronBinding(name);\n    }\n    else {\n        return null;\n    }\n};\nexports.getElectronBinding = getElectronBinding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGMtY29tcGF0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BlbGVjdHJvbityZW1vdGVAMi4wLjUvbm9kZV9tb2R1bGVzL0BlbGVjdHJvbi9yZW1vdGUvZGlzdC9zcmMvY29tbW9uL2dldC1lbGVjdHJvbi1iaW5kaW5nLmpzPzAxMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVsZWN0cm9uQmluZGluZyA9IHZvaWQgMDtcbmNvbnN0IGdldEVsZWN0cm9uQmluZGluZyA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuX2xpbmtlZEJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuX2xpbmtlZEJpbmRpbmcoJ2VsZWN0cm9uX2NvbW1vbl8nICsgbmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZWxlY3Ryb25CaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVsZWN0cm9uQmluZGluZyhuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLmdldEVsZWN0cm9uQmluZGluZyA9IGdldEVsZWN0cm9uQmluZGluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///749\n")},300:(__unused_webpack_module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserialize = exports.serialize = exports.isSerializableObject = exports.isPromise = void 0;\nconst electron_1 = __webpack_require__(496);\nfunction isPromise(val) {\n    return (val &&\n        val.then &&\n        val.then instanceof Function &&\n        val.constructor &&\n        val.constructor.reject &&\n        val.constructor.reject instanceof Function &&\n        val.constructor.resolve &&\n        val.constructor.resolve instanceof Function);\n}\nexports.isPromise = isPromise;\nconst serializableTypes = [\n    Boolean,\n    Number,\n    String,\n    Date,\n    Error,\n    RegExp,\n    ArrayBuffer\n];\n// https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#Supported_types\nfunction isSerializableObject(value) {\n    return value === null || ArrayBuffer.isView(value) || serializableTypes.some(type => value instanceof type);\n}\nexports.isSerializableObject = isSerializableObject;\nconst objectMap = function (source, mapper) {\n    const sourceEntries = Object.entries(source);\n    const targetEntries = sourceEntries.map(([key, val]) => [key, mapper(val)]);\n    return Object.fromEntries(targetEntries);\n};\nfunction serializeNativeImage(image) {\n    const representations = [];\n    const scaleFactors = image.getScaleFactors();\n    // Use Buffer when there's only one representation for better perf.\n    // This avoids compressing to/from PNG where it's not necessary to\n    // ensure uniqueness of dataURLs (since there's only one).\n    if (scaleFactors.length === 1) {\n        const scaleFactor = scaleFactors[0];\n        const size = image.getSize(scaleFactor);\n        const buffer = image.toBitmap({ scaleFactor });\n        representations.push({ scaleFactor, size, buffer });\n    }\n    else {\n        // Construct from dataURLs to ensure that they are not lost in creation.\n        for (const scaleFactor of scaleFactors) {\n            const size = image.getSize(scaleFactor);\n            const dataURL = image.toDataURL({ scaleFactor });\n            representations.push({ scaleFactor, size, dataURL });\n        }\n    }\n    return { __ELECTRON_SERIALIZED_NativeImage__: true, representations };\n}\nfunction deserializeNativeImage(value) {\n    const image = electron_1.nativeImage.createEmpty();\n    // Use Buffer when there's only one representation for better perf.\n    // This avoids compressing to/from PNG where it's not necessary to\n    // ensure uniqueness of dataURLs (since there's only one).\n    if (value.representations.length === 1) {\n        const { buffer, size, scaleFactor } = value.representations[0];\n        const { width, height } = size;\n        image.addRepresentation({ buffer, scaleFactor, width, height });\n    }\n    else {\n        // Construct from dataURLs to ensure that they are not lost in creation.\n        for (const rep of value.representations) {\n            const { dataURL, size, scaleFactor } = rep;\n            const { width, height } = size;\n            image.addRepresentation({ dataURL, scaleFactor, width, height });\n        }\n    }\n    return image;\n}\nfunction serialize(value) {\n    if (value && value.constructor && value.constructor.name === 'NativeImage') {\n        return serializeNativeImage(value);\n    }\n    if (Array.isArray(value)) {\n        return value.map(serialize);\n    }\n    else if (isSerializableObject(value)) {\n        return value;\n    }\n    else if (value instanceof Object) {\n        return objectMap(value, serialize);\n    }\n    else {\n        return value;\n    }\n}\nexports.serialize = serialize;\nfunction deserialize(value) {\n    if (value && value.__ELECTRON_SERIALIZED_NativeImage__) {\n        return deserializeNativeImage(value);\n    }\n    else if (Array.isArray(value)) {\n        return value.map(deserialize);\n    }\n    else if (isSerializableObject(value)) {\n        return value;\n    }\n    else if (value instanceof Object) {\n        return objectMap(value, deserialize);\n    }\n    else {\n        return value;\n    }\n}\nexports.deserialize = deserialize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLDRCQUE0QixHQUFHLGlCQUFpQjtBQUMxRixtQkFBbUIsbUJBQU8sQ0FBQyxHQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRCwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRCxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDLGdCQUFnQixnQkFBZ0I7QUFDaEMsa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQsb0JBQW9CLGdCQUFnQjtBQUNwQyxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGMtY29tcGF0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BlbGVjdHJvbityZW1vdGVAMi4wLjUvbm9kZV9tb2R1bGVzL0BlbGVjdHJvbi9yZW1vdGUvZGlzdC9zcmMvY29tbW9uL3R5cGUtdXRpbHMuanM/NzFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBleHBvcnRzLnNlcmlhbGl6ZSA9IGV4cG9ydHMuaXNTZXJpYWxpemFibGVPYmplY3QgPSBleHBvcnRzLmlzUHJvbWlzZSA9IHZvaWQgMDtcbmNvbnN0IGVsZWN0cm9uXzEgPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gICAgcmV0dXJuICh2YWwgJiZcbiAgICAgICAgdmFsLnRoZW4gJiZcbiAgICAgICAgdmFsLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbiAmJlxuICAgICAgICB2YWwuY29uc3RydWN0b3IgJiZcbiAgICAgICAgdmFsLmNvbnN0cnVjdG9yLnJlamVjdCAmJlxuICAgICAgICB2YWwuY29uc3RydWN0b3IucmVqZWN0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiZcbiAgICAgICAgdmFsLmNvbnN0cnVjdG9yLnJlc29sdmUgJiZcbiAgICAgICAgdmFsLmNvbnN0cnVjdG9yLnJlc29sdmUgaW5zdGFuY2VvZiBGdW5jdGlvbik7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmNvbnN0IHNlcmlhbGl6YWJsZVR5cGVzID0gW1xuICAgIEJvb2xlYW4sXG4gICAgTnVtYmVyLFxuICAgIFN0cmluZyxcbiAgICBEYXRlLFxuICAgIEVycm9yLFxuICAgIFJlZ0V4cCxcbiAgICBBcnJheUJ1ZmZlclxuXTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfV29ya2Vyc19BUEkvU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0jU3VwcG9ydGVkX3R5cGVzXG5mdW5jdGlvbiBpc1NlcmlhbGl6YWJsZU9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IHNlcmlhbGl6YWJsZVR5cGVzLnNvbWUodHlwZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHR5cGUpO1xufVxuZXhwb3J0cy5pc1NlcmlhbGl6YWJsZU9iamVjdCA9IGlzU2VyaWFsaXphYmxlT2JqZWN0O1xuY29uc3Qgb2JqZWN0TWFwID0gZnVuY3Rpb24gKHNvdXJjZSwgbWFwcGVyKSB7XG4gICAgY29uc3Qgc291cmNlRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNvdXJjZSk7XG4gICAgY29uc3QgdGFyZ2V0RW50cmllcyA9IHNvdXJjZUVudHJpZXMubWFwKChba2V5LCB2YWxdKSA9PiBba2V5LCBtYXBwZXIodmFsKV0pO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGFyZ2V0RW50cmllcyk7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplTmF0aXZlSW1hZ2UoaW1hZ2UpIHtcbiAgICBjb25zdCByZXByZXNlbnRhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBzY2FsZUZhY3RvcnMgPSBpbWFnZS5nZXRTY2FsZUZhY3RvcnMoKTtcbiAgICAvLyBVc2UgQnVmZmVyIHdoZW4gdGhlcmUncyBvbmx5IG9uZSByZXByZXNlbnRhdGlvbiBmb3IgYmV0dGVyIHBlcmYuXG4gICAgLy8gVGhpcyBhdm9pZHMgY29tcHJlc3NpbmcgdG8vZnJvbSBQTkcgd2hlcmUgaXQncyBub3QgbmVjZXNzYXJ5IHRvXG4gICAgLy8gZW5zdXJlIHVuaXF1ZW5lc3Mgb2YgZGF0YVVSTHMgKHNpbmNlIHRoZXJlJ3Mgb25seSBvbmUpLlxuICAgIGlmIChzY2FsZUZhY3RvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3JzWzBdO1xuICAgICAgICBjb25zdCBzaXplID0gaW1hZ2UuZ2V0U2l6ZShzY2FsZUZhY3Rvcik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGltYWdlLnRvQml0bWFwKHsgc2NhbGVGYWN0b3IgfSk7XG4gICAgICAgIHJlcHJlc2VudGF0aW9ucy5wdXNoKHsgc2NhbGVGYWN0b3IsIHNpemUsIGJ1ZmZlciB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBmcm9tIGRhdGFVUkxzIHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlIG5vdCBsb3N0IGluIGNyZWF0aW9uLlxuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlRmFjdG9yIG9mIHNjYWxlRmFjdG9ycykge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGltYWdlLmdldFNpemUoc2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVVSTCA9IGltYWdlLnRvRGF0YVVSTCh7IHNjYWxlRmFjdG9yIH0pO1xuICAgICAgICAgICAgcmVwcmVzZW50YXRpb25zLnB1c2goeyBzY2FsZUZhY3Rvciwgc2l6ZSwgZGF0YVVSTCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBfX0VMRUNUUk9OX1NFUklBTElaRURfTmF0aXZlSW1hZ2VfXzogdHJ1ZSwgcmVwcmVzZW50YXRpb25zIH07XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZU5hdGl2ZUltYWdlKHZhbHVlKSB7XG4gICAgY29uc3QgaW1hZ2UgPSBlbGVjdHJvbl8xLm5hdGl2ZUltYWdlLmNyZWF0ZUVtcHR5KCk7XG4gICAgLy8gVXNlIEJ1ZmZlciB3aGVuIHRoZXJlJ3Mgb25seSBvbmUgcmVwcmVzZW50YXRpb24gZm9yIGJldHRlciBwZXJmLlxuICAgIC8vIFRoaXMgYXZvaWRzIGNvbXByZXNzaW5nIHRvL2Zyb20gUE5HIHdoZXJlIGl0J3Mgbm90IG5lY2Vzc2FyeSB0b1xuICAgIC8vIGVuc3VyZSB1bmlxdWVuZXNzIG9mIGRhdGFVUkxzIChzaW5jZSB0aGVyZSdzIG9ubHkgb25lKS5cbiAgICBpZiAodmFsdWUucmVwcmVzZW50YXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgc2l6ZSwgc2NhbGVGYWN0b3IgfSA9IHZhbHVlLnJlcHJlc2VudGF0aW9uc1swXTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzaXplO1xuICAgICAgICBpbWFnZS5hZGRSZXByZXNlbnRhdGlvbih7IGJ1ZmZlciwgc2NhbGVGYWN0b3IsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgZnJvbSBkYXRhVVJMcyB0byBlbnN1cmUgdGhhdCB0aGV5IGFyZSBub3QgbG9zdCBpbiBjcmVhdGlvbi5cbiAgICAgICAgZm9yIChjb25zdCByZXAgb2YgdmFsdWUucmVwcmVzZW50YXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFVUkwsIHNpemUsIHNjYWxlRmFjdG9yIH0gPSByZXA7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemU7XG4gICAgICAgICAgICBpbWFnZS5hZGRSZXByZXNlbnRhdGlvbih7IGRhdGFVUkwsIHNjYWxlRmFjdG9yLCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnTmF0aXZlSW1hZ2UnKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVOYXRpdmVJbWFnZSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKHNlcmlhbGl6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VyaWFsaXphYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3RNYXAodmFsdWUsIHNlcmlhbGl6ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5fX0VMRUNUUk9OX1NFUklBTElaRURfTmF0aXZlSW1hZ2VfXykge1xuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVOYXRpdmVJbWFnZSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZGVzZXJpYWxpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NlcmlhbGl6YWJsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0TWFwKHZhbHVlLCBkZXNlcmlhbGl6ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///300\n")},820:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\nexports.enable = exports.initialize = void 0;\nvar server_1 = __webpack_require__(118);\nObject.defineProperty(exports, "initialize", ({ enumerable: true, get: function () { return server_1.initialize; } }));\nObject.defineProperty(exports, "enable", ({ enumerable: true, get: function () { return server_1.enable; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIwLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDZCQUE2QyxFQUFFLGFBQWEsQ0FBQztBQUM3RCxjQUFjLEdBQUcsa0JBQWtCO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxHQUFVO0FBQ2pDLDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYy1jb21wYXQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGVsZWN0cm9uK3JlbW90ZUAyLjAuNS9ub2RlX21vZHVsZXMvQGVsZWN0cm9uL3JlbW90ZS9kaXN0L3NyYy9tYWluL2luZGV4LmpzPzg3NWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuYWJsZSA9IGV4cG9ydHMuaW5pdGlhbGl6ZSA9IHZvaWQgMDtcbnZhciBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaXRpYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl8xLmluaXRpYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmFibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl8xLmVuYWJsZTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///820\n')},953:(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst getOwnerKey = (webContents, contextId) => {\n    return `${webContents.id}-${contextId}`;\n};\nclass ObjectsRegistry {\n    constructor() {\n        this.nextId = 0;\n        // Stores all objects by ref-counting.\n        // (id) => {object, count}\n        this.storage = {};\n        // Stores the IDs + refCounts of objects referenced by WebContents.\n        // (ownerKey) => { id: refCount }\n        this.owners = {};\n        this.electronIds = new WeakMap();\n    }\n    // Register a new object and return its assigned ID. If the object is already\n    // registered then the already assigned ID would be returned.\n    add(webContents, contextId, obj) {\n        // Get or assign an ID to the object.\n        const id = this.saveToStorage(obj);\n        // Add object to the set of referenced objects.\n        const ownerKey = getOwnerKey(webContents, contextId);\n        let owner = this.owners[ownerKey];\n        if (!owner) {\n            owner = this.owners[ownerKey] = new Map();\n            this.registerDeleteListener(webContents, contextId);\n        }\n        if (!owner.has(id)) {\n            owner.set(id, 0);\n            // Increase reference count if not referenced before.\n            this.storage[id].count++;\n        }\n        owner.set(id, owner.get(id) + 1);\n        return id;\n    }\n    // Get an object according to its ID.\n    get(id) {\n        const pointer = this.storage[id];\n        if (pointer != null)\n            return pointer.object;\n    }\n    // Dereference an object according to its ID.\n    // Note that an object may be double-freed (cleared when page is reloaded, and\n    // then garbage collected in old page).\n    remove(webContents, contextId, id) {\n        const ownerKey = getOwnerKey(webContents, contextId);\n        const owner = this.owners[ownerKey];\n        if (owner && owner.has(id)) {\n            const newRefCount = owner.get(id) - 1;\n            // Only completely remove if the number of references GCed in the\n            // renderer is the same as the number of references we sent them\n            if (newRefCount <= 0) {\n                // Remove the reference in owner.\n                owner.delete(id);\n                // Dereference from the storage.\n                this.dereference(id);\n            }\n            else {\n                owner.set(id, newRefCount);\n            }\n        }\n    }\n    // Clear all references to objects refrenced by the WebContents.\n    clear(webContents, contextId) {\n        const ownerKey = getOwnerKey(webContents, contextId);\n        const owner = this.owners[ownerKey];\n        if (!owner)\n            return;\n        for (const id of owner.keys())\n            this.dereference(id);\n        delete this.owners[ownerKey];\n    }\n    // Saves the object into storage and assigns an ID for it.\n    saveToStorage(object) {\n        let id = this.electronIds.get(object);\n        if (!id) {\n            id = ++this.nextId;\n            this.storage[id] = {\n                count: 0,\n                object: object\n            };\n            this.electronIds.set(object, id);\n        }\n        return id;\n    }\n    // Dereference the object from store.\n    dereference(id) {\n        const pointer = this.storage[id];\n        if (pointer == null) {\n            return;\n        }\n        pointer.count -= 1;\n        if (pointer.count === 0) {\n            this.electronIds.delete(pointer.object);\n            delete this.storage[id];\n        }\n    }\n    // Clear the storage when renderer process is destroyed.\n    registerDeleteListener(webContents, contextId) {\n        // contextId => ${processHostId}-${contextCount}\n        const processHostId = contextId.split(\'-\')[0];\n        const listener = (_, deletedProcessHostId) => {\n            if (deletedProcessHostId &&\n                deletedProcessHostId.toString() === processHostId) {\n                webContents.removeListener(\'render-view-deleted\', listener);\n                this.clear(webContents, contextId);\n            }\n        };\n        // Note that the "render-view-deleted" event may not be emitted on time when\n        // the renderer process get destroyed because of navigation, we rely on the\n        // renderer process to send "ELECTRON_BROWSER_CONTEXT_RELEASE" message to\n        // guard this situation.\n        webContents.on(\'render-view-deleted\', listener);\n    }\n}\nexports["default"] = new ObjectsRegistry();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0EsY0FBYyxlQUFlLEdBQUcsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWMsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3BjLWNvbXBhdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZWxlY3Ryb24rcmVtb3RlQDIuMC41L25vZGVfbW9kdWxlcy9AZWxlY3Ryb24vcmVtb3RlL2Rpc3Qvc3JjL21haW4vb2JqZWN0cy1yZWdpc3RyeS5qcz81ODM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZ2V0T3duZXJLZXkgPSAod2ViQ29udGVudHMsIGNvbnRleHRJZCkgPT4ge1xuICAgIHJldHVybiBgJHt3ZWJDb250ZW50cy5pZH0tJHtjb250ZXh0SWR9YDtcbn07XG5jbGFzcyBPYmplY3RzUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgICAgIC8vIFN0b3JlcyBhbGwgb2JqZWN0cyBieSByZWYtY291bnRpbmcuXG4gICAgICAgIC8vIChpZCkgPT4ge29iamVjdCwgY291bnR9XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICAgICAgICAvLyBTdG9yZXMgdGhlIElEcyArIHJlZkNvdW50cyBvZiBvYmplY3RzIHJlZmVyZW5jZWQgYnkgV2ViQ29udGVudHMuXG4gICAgICAgIC8vIChvd25lcktleSkgPT4geyBpZDogcmVmQ291bnQgfVxuICAgICAgICB0aGlzLm93bmVycyA9IHt9O1xuICAgICAgICB0aGlzLmVsZWN0cm9uSWRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgLy8gUmVnaXN0ZXIgYSBuZXcgb2JqZWN0IGFuZCByZXR1cm4gaXRzIGFzc2lnbmVkIElELiBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHlcbiAgICAvLyByZWdpc3RlcmVkIHRoZW4gdGhlIGFscmVhZHkgYXNzaWduZWQgSUQgd291bGQgYmUgcmV0dXJuZWQuXG4gICAgYWRkKHdlYkNvbnRlbnRzLCBjb250ZXh0SWQsIG9iaikge1xuICAgICAgICAvLyBHZXQgb3IgYXNzaWduIGFuIElEIHRvIHRoZSBvYmplY3QuXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5zYXZlVG9TdG9yYWdlKG9iaik7XG4gICAgICAgIC8vIEFkZCBvYmplY3QgdG8gdGhlIHNldCBvZiByZWZlcmVuY2VkIG9iamVjdHMuXG4gICAgICAgIGNvbnN0IG93bmVyS2V5ID0gZ2V0T3duZXJLZXkod2ViQ29udGVudHMsIGNvbnRleHRJZCk7XG4gICAgICAgIGxldCBvd25lciA9IHRoaXMub3duZXJzW293bmVyS2V5XTtcbiAgICAgICAgaWYgKCFvd25lcikge1xuICAgICAgICAgICAgb3duZXIgPSB0aGlzLm93bmVyc1tvd25lcktleV0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRGVsZXRlTGlzdGVuZXIod2ViQ29udGVudHMsIGNvbnRleHRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvd25lci5oYXMoaWQpKSB7XG4gICAgICAgICAgICBvd25lci5zZXQoaWQsIDApO1xuICAgICAgICAgICAgLy8gSW5jcmVhc2UgcmVmZXJlbmNlIGNvdW50IGlmIG5vdCByZWZlcmVuY2VkIGJlZm9yZS5cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZVtpZF0uY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBvd25lci5zZXQoaWQsIG93bmVyLmdldChpZCkgKyAxKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvLyBHZXQgYW4gb2JqZWN0IGFjY29yZGluZyB0byBpdHMgSUQuXG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLnN0b3JhZ2VbaWRdO1xuICAgICAgICBpZiAocG9pbnRlciAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXIub2JqZWN0O1xuICAgIH1cbiAgICAvLyBEZXJlZmVyZW5jZSBhbiBvYmplY3QgYWNjb3JkaW5nIHRvIGl0cyBJRC5cbiAgICAvLyBOb3RlIHRoYXQgYW4gb2JqZWN0IG1heSBiZSBkb3VibGUtZnJlZWQgKGNsZWFyZWQgd2hlbiBwYWdlIGlzIHJlbG9hZGVkLCBhbmRcbiAgICAvLyB0aGVuIGdhcmJhZ2UgY29sbGVjdGVkIGluIG9sZCBwYWdlKS5cbiAgICByZW1vdmUod2ViQ29udGVudHMsIGNvbnRleHRJZCwgaWQpIHtcbiAgICAgICAgY29uc3Qgb3duZXJLZXkgPSBnZXRPd25lcktleSh3ZWJDb250ZW50cywgY29udGV4dElkKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSB0aGlzLm93bmVyc1tvd25lcktleV07XG4gICAgICAgIGlmIChvd25lciAmJiBvd25lci5oYXMoaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdSZWZDb3VudCA9IG93bmVyLmdldChpZCkgLSAxO1xuICAgICAgICAgICAgLy8gT25seSBjb21wbGV0ZWx5IHJlbW92ZSBpZiB0aGUgbnVtYmVyIG9mIHJlZmVyZW5jZXMgR0NlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHJlbmRlcmVyIGlzIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgcmVmZXJlbmNlcyB3ZSBzZW50IHRoZW1cbiAgICAgICAgICAgIGlmIChuZXdSZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWZlcmVuY2UgaW4gb3duZXIuXG4gICAgICAgICAgICAgICAgb3duZXIuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSBmcm9tIHRoZSBzdG9yYWdlLlxuICAgICAgICAgICAgICAgIHRoaXMuZGVyZWZlcmVuY2UoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duZXIuc2V0KGlkLCBuZXdSZWZDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYXIgYWxsIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyByZWZyZW5jZWQgYnkgdGhlIFdlYkNvbnRlbnRzLlxuICAgIGNsZWFyKHdlYkNvbnRlbnRzLCBjb250ZXh0SWQpIHtcbiAgICAgICAgY29uc3Qgb3duZXJLZXkgPSBnZXRPd25lcktleSh3ZWJDb250ZW50cywgY29udGV4dElkKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSB0aGlzLm93bmVyc1tvd25lcktleV07XG4gICAgICAgIGlmICghb3duZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2Ygb3duZXIua2V5cygpKVxuICAgICAgICAgICAgdGhpcy5kZXJlZmVyZW5jZShpZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm93bmVyc1tvd25lcktleV07XG4gICAgfVxuICAgIC8vIFNhdmVzIHRoZSBvYmplY3QgaW50byBzdG9yYWdlIGFuZCBhc3NpZ25zIGFuIElEIGZvciBpdC5cbiAgICBzYXZlVG9TdG9yYWdlKG9iamVjdCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmVsZWN0cm9uSWRzLmdldChvYmplY3QpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9ICsrdGhpcy5uZXh0SWQ7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VbaWRdID0ge1xuICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbGVjdHJvbklkcy5zZXQob2JqZWN0LCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvLyBEZXJlZmVyZW5jZSB0aGUgb2JqZWN0IGZyb20gc3RvcmUuXG4gICAgZGVyZWZlcmVuY2UoaWQpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMuc3RvcmFnZVtpZF07XG4gICAgICAgIGlmIChwb2ludGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwb2ludGVyLmNvdW50IC09IDE7XG4gICAgICAgIGlmIChwb2ludGVyLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVsZWN0cm9uSWRzLmRlbGV0ZShwb2ludGVyLm9iamVjdCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2lkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhciB0aGUgc3RvcmFnZSB3aGVuIHJlbmRlcmVyIHByb2Nlc3MgaXMgZGVzdHJveWVkLlxuICAgIHJlZ2lzdGVyRGVsZXRlTGlzdGVuZXIod2ViQ29udGVudHMsIGNvbnRleHRJZCkge1xuICAgICAgICAvLyBjb250ZXh0SWQgPT4gJHtwcm9jZXNzSG9zdElkfS0ke2NvbnRleHRDb3VudH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc0hvc3RJZCA9IGNvbnRleHRJZC5zcGxpdCgnLScpWzBdO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChfLCBkZWxldGVkUHJvY2Vzc0hvc3RJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlbGV0ZWRQcm9jZXNzSG9zdElkICYmXG4gICAgICAgICAgICAgICAgZGVsZXRlZFByb2Nlc3NIb3N0SWQudG9TdHJpbmcoKSA9PT0gcHJvY2Vzc0hvc3RJZCkge1xuICAgICAgICAgICAgICAgIHdlYkNvbnRlbnRzLnJlbW92ZUxpc3RlbmVyKCdyZW5kZXItdmlldy1kZWxldGVkJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIod2ViQ29udGVudHMsIGNvbnRleHRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgXCJyZW5kZXItdmlldy1kZWxldGVkXCIgZXZlbnQgbWF5IG5vdCBiZSBlbWl0dGVkIG9uIHRpbWUgd2hlblxuICAgICAgICAvLyB0aGUgcmVuZGVyZXIgcHJvY2VzcyBnZXQgZGVzdHJveWVkIGJlY2F1c2Ugb2YgbmF2aWdhdGlvbiwgd2UgcmVseSBvbiB0aGVcbiAgICAgICAgLy8gcmVuZGVyZXIgcHJvY2VzcyB0byBzZW5kIFwiRUxFQ1RST05fQlJPV1NFUl9DT05URVhUX1JFTEVBU0VcIiBtZXNzYWdlIHRvXG4gICAgICAgIC8vIGd1YXJkIHRoaXMgc2l0dWF0aW9uLlxuICAgICAgICB3ZWJDb250ZW50cy5vbigncmVuZGVyLXZpZXctZGVsZXRlZCcsIGxpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgT2JqZWN0c1JlZ2lzdHJ5KCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///953\n')},118:function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initialize = exports.enable = exports.isRemoteModuleEnabled = void 0;\nconst events_1 = __webpack_require__(100);\nconst objects_registry_1 = __importDefault(__webpack_require__(953));\nconst type_utils_1 = __webpack_require__(300);\nconst electron_1 = __webpack_require__(496);\nconst get_electron_binding_1 = __webpack_require__(749);\nconst v8Util = get_electron_binding_1.getElectronBinding('v8_util');\nconst hasWebPrefsRemoteModuleAPI = (() => {\n    var _a, _b;\n    const electronVersion = Number((_b = (_a = process.versions.electron) === null || _a === void 0 ? void 0 : _a.split(\".\")) === null || _b === void 0 ? void 0 : _b[0]);\n    return Number.isNaN(electronVersion) || electronVersion < 14;\n})();\n// The internal properties of Function.\nconst FUNCTION_PROPERTIES = [\n    'length', 'name', 'arguments', 'caller', 'prototype'\n];\n// The remote functions in renderer processes.\nconst rendererFunctionCache = new Map();\n// eslint-disable-next-line no-undef\nconst finalizationRegistry = new FinalizationRegistry((fi) => {\n    const mapKey = fi.id[0] + '~' + fi.id[1];\n    const ref = rendererFunctionCache.get(mapKey);\n    if (ref !== undefined && ref.deref() === undefined) {\n        rendererFunctionCache.delete(mapKey);\n        if (!fi.webContents.isDestroyed()) {\n            try {\n                fi.webContents.sendToFrame(fi.frameId, \"REMOTE_RENDERER_RELEASE_CALLBACK\" /* RENDERER_RELEASE_CALLBACK */, fi.id[0], fi.id[1]);\n            }\n            catch (error) {\n                console.warn(`sendToFrame() failed: ${error}`);\n            }\n        }\n    }\n});\nfunction getCachedRendererFunction(id) {\n    const mapKey = id[0] + '~' + id[1];\n    const ref = rendererFunctionCache.get(mapKey);\n    if (ref !== undefined) {\n        const deref = ref.deref();\n        if (deref !== undefined)\n            return deref;\n    }\n}\nfunction setCachedRendererFunction(id, wc, frameId, value) {\n    // eslint-disable-next-line no-undef\n    const wr = new WeakRef(value);\n    const mapKey = id[0] + '~' + id[1];\n    rendererFunctionCache.set(mapKey, wr);\n    finalizationRegistry.register(value, {\n        id,\n        webContents: wc,\n        frameId\n    });\n    return value;\n}\nconst locationInfo = new WeakMap();\n// Return the description of object's members:\nconst getObjectMembers = function (object) {\n    let names = Object.getOwnPropertyNames(object);\n    // For Function, we should not override following properties even though they\n    // are \"own\" properties.\n    if (typeof object === 'function') {\n        names = names.filter((name) => {\n            return !FUNCTION_PROPERTIES.includes(name);\n        });\n    }\n    // Map properties to descriptors.\n    return names.map((name) => {\n        const descriptor = Object.getOwnPropertyDescriptor(object, name);\n        let type;\n        let writable = false;\n        if (descriptor.get === undefined && typeof object[name] === 'function') {\n            type = 'method';\n        }\n        else {\n            if (descriptor.set || descriptor.writable)\n                writable = true;\n            type = 'get';\n        }\n        return { name, enumerable: descriptor.enumerable, writable, type };\n    });\n};\n// Return the description of object's prototype.\nconst getObjectPrototype = function (object) {\n    const proto = Object.getPrototypeOf(object);\n    if (proto === null || proto === Object.prototype)\n        return null;\n    return {\n        members: getObjectMembers(proto),\n        proto: getObjectPrototype(proto)\n    };\n};\n// Convert a real value into meta data.\nconst valueToMeta = function (sender, contextId, value, optimizeSimpleObject = false) {\n    // Determine the type of value.\n    let type;\n    switch (typeof value) {\n        case 'object':\n            // Recognize certain types of objects.\n            if (value instanceof Buffer) {\n                type = 'buffer';\n            }\n            else if (value && value.constructor && value.constructor.name === 'NativeImage') {\n                type = 'nativeimage';\n            }\n            else if (Array.isArray(value)) {\n                type = 'array';\n            }\n            else if (value instanceof Error) {\n                type = 'error';\n            }\n            else if (type_utils_1.isSerializableObject(value)) {\n                type = 'value';\n            }\n            else if (type_utils_1.isPromise(value)) {\n                type = 'promise';\n            }\n            else if (Object.prototype.hasOwnProperty.call(value, 'callee') && value.length != null) {\n                // Treat the arguments object as array.\n                type = 'array';\n            }\n            else if (optimizeSimpleObject && v8Util.getHiddenValue(value, 'simple')) {\n                // Treat simple objects as value.\n                type = 'value';\n            }\n            else {\n                type = 'object';\n            }\n            break;\n        case 'function':\n            type = 'function';\n            break;\n        default:\n            type = 'value';\n            break;\n    }\n    // Fill the meta object according to value's type.\n    if (type === 'array') {\n        return {\n            type,\n            members: value.map((el) => valueToMeta(sender, contextId, el, optimizeSimpleObject))\n        };\n    }\n    else if (type === 'nativeimage') {\n        return { type, value: type_utils_1.serialize(value) };\n    }\n    else if (type === 'object' || type === 'function') {\n        return {\n            type,\n            name: value.constructor ? value.constructor.name : '',\n            // Reference the original value if it's an object, because when it's\n            // passed to renderer we would assume the renderer keeps a reference of\n            // it.\n            id: objects_registry_1.default.add(sender, contextId, value),\n            members: getObjectMembers(value),\n            proto: getObjectPrototype(value)\n        };\n    }\n    else if (type === 'buffer') {\n        return { type, value };\n    }\n    else if (type === 'promise') {\n        // Add default handler to prevent unhandled rejections in main process\n        // Instead they should appear in the renderer process\n        value.then(function () { }, function () { });\n        return {\n            type,\n            then: valueToMeta(sender, contextId, function (onFulfilled, onRejected) {\n                value.then(onFulfilled, onRejected);\n            })\n        };\n    }\n    else if (type === 'error') {\n        return {\n            type,\n            value,\n            members: Object.keys(value).map(name => ({\n                name,\n                value: valueToMeta(sender, contextId, value[name])\n            }))\n        };\n    }\n    else {\n        return {\n            type: 'value',\n            value\n        };\n    }\n};\nconst throwRPCError = function (message) {\n    const error = new Error(message);\n    error.code = 'EBADRPC';\n    error.errno = -72;\n    throw error;\n};\nconst removeRemoteListenersAndLogWarning = (sender, callIntoRenderer) => {\n    const location = locationInfo.get(callIntoRenderer);\n    let message = 'Attempting to call a function in a renderer window that has been closed or released.' +\n        `\\nFunction provided here: ${location}`;\n    if (sender instanceof events_1.EventEmitter) {\n        const remoteEvents = sender.eventNames().filter((eventName) => {\n            return sender.listeners(eventName).includes(callIntoRenderer);\n        });\n        if (remoteEvents.length > 0) {\n            message += `\\nRemote event names: ${remoteEvents.join(', ')}`;\n            remoteEvents.forEach((eventName) => {\n                sender.removeListener(eventName, callIntoRenderer);\n            });\n        }\n    }\n    console.warn(message);\n};\nconst fakeConstructor = (constructor, name) => new Proxy(Object, {\n    get(target, prop, receiver) {\n        if (prop === 'name') {\n            return name;\n        }\n        else {\n            return Reflect.get(target, prop, receiver);\n        }\n    }\n});\n// Convert array of meta data from renderer into array of real values.\nconst unwrapArgs = function (sender, frameId, contextId, args) {\n    const metaToValue = function (meta) {\n        switch (meta.type) {\n            case 'nativeimage':\n                return type_utils_1.deserialize(meta.value);\n            case 'value':\n                return meta.value;\n            case 'remote-object':\n                return objects_registry_1.default.get(meta.id);\n            case 'array':\n                return unwrapArgs(sender, frameId, contextId, meta.value);\n            case 'buffer':\n                return Buffer.from(meta.value.buffer, meta.value.byteOffset, meta.value.byteLength);\n            case 'promise':\n                return Promise.resolve({\n                    then: metaToValue(meta.then)\n                });\n            case 'object': {\n                const ret = meta.name !== 'Object' ? Object.create({\n                    constructor: fakeConstructor(Object, meta.name)\n                }) : {};\n                for (const { name, value } of meta.members) {\n                    ret[name] = metaToValue(value);\n                }\n                return ret;\n            }\n            case 'function-with-return-value': {\n                const returnValue = metaToValue(meta.value);\n                return function () {\n                    return returnValue;\n                };\n            }\n            case 'function': {\n                // Merge contextId and meta.id, since meta.id can be the same in\n                // different webContents.\n                const objectId = [contextId, meta.id];\n                // Cache the callbacks in renderer.\n                const cachedFunction = getCachedRendererFunction(objectId);\n                if (cachedFunction !== undefined) {\n                    return cachedFunction;\n                }\n                const callIntoRenderer = function (...args) {\n                    let succeed = false;\n                    if (!sender.isDestroyed()) {\n                        try {\n                            succeed = sender.sendToFrame(frameId, \"REMOTE_RENDERER_CALLBACK\" /* RENDERER_CALLBACK */, contextId, meta.id, valueToMeta(sender, contextId, args)) !== false;\n                        }\n                        catch (error) {\n                            console.warn(`sendToFrame() failed: ${error}`);\n                        }\n                    }\n                    if (!succeed) {\n                        removeRemoteListenersAndLogWarning(this, callIntoRenderer);\n                    }\n                };\n                locationInfo.set(callIntoRenderer, meta.location);\n                Object.defineProperty(callIntoRenderer, 'length', { value: meta.length });\n                setCachedRendererFunction(objectId, sender, frameId, callIntoRenderer);\n                return callIntoRenderer;\n            }\n            default:\n                throw new TypeError(`Unknown type: ${meta.type}`);\n        }\n    };\n    return args.map(metaToValue);\n};\nconst isRemoteModuleEnabledImpl = function (contents) {\n    const webPreferences = contents.getLastWebPreferences() || {};\n    return webPreferences.enableRemoteModule != null ? !!webPreferences.enableRemoteModule : false;\n};\nconst isRemoteModuleEnabledCache = new WeakMap();\nconst isRemoteModuleEnabled = function (contents) {\n    if (hasWebPrefsRemoteModuleAPI && !isRemoteModuleEnabledCache.has(contents)) {\n        isRemoteModuleEnabledCache.set(contents, isRemoteModuleEnabledImpl(contents));\n    }\n    return isRemoteModuleEnabledCache.get(contents);\n};\nexports.isRemoteModuleEnabled = isRemoteModuleEnabled;\nfunction enable(contents) {\n    isRemoteModuleEnabledCache.set(contents, true);\n}\nexports.enable = enable;\nconst handleRemoteCommand = function (channel, handler) {\n    electron_1.ipcMain.on(channel, (event, contextId, ...args) => {\n        let returnValue;\n        if (!exports.isRemoteModuleEnabled(event.sender)) {\n            event.returnValue = {\n                type: 'exception',\n                value: valueToMeta(event.sender, contextId, new Error('@electron/remote is disabled for this WebContents. Call require(\"@electron/remote/main\").enable(webContents) to enable it.'))\n            };\n            return;\n        }\n        try {\n            returnValue = handler(event, contextId, ...args);\n        }\n        catch (error) {\n            returnValue = {\n                type: 'exception',\n                value: valueToMeta(event.sender, contextId, error),\n            };\n        }\n        if (returnValue !== undefined) {\n            event.returnValue = returnValue;\n        }\n    });\n};\nconst emitCustomEvent = function (contents, eventName, ...args) {\n    const event = { sender: contents, returnValue: undefined, defaultPrevented: false };\n    electron_1.app.emit(eventName, event, contents, ...args);\n    contents.emit(eventName, event, ...args);\n    return event;\n};\nconst logStack = function (contents, code, stack) {\n    if (stack) {\n        console.warn(`WebContents (${contents.id}): ${code}`, stack);\n    }\n};\nlet initialized = false;\nfunction initialize() {\n    if (initialized)\n        throw new Error('@electron/remote has already been initialized');\n    initialized = true;\n    handleRemoteCommand(\"REMOTE_BROWSER_WRONG_CONTEXT_ERROR\" /* BROWSER_WRONG_CONTEXT_ERROR */, function (event, contextId, passedContextId, id) {\n        const objectId = [passedContextId, id];\n        const cachedFunction = getCachedRendererFunction(objectId);\n        if (cachedFunction === undefined) {\n            // Do nothing if the error has already been reported before.\n            return;\n        }\n        removeRemoteListenersAndLogWarning(event.sender, cachedFunction);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_REQUIRE\" /* BROWSER_REQUIRE */, function (event, contextId, moduleName, stack) {\n        logStack(event.sender, `remote.require('${moduleName}')`, stack);\n        const customEvent = emitCustomEvent(event.sender, 'remote-require', moduleName);\n        if (customEvent.returnValue === undefined) {\n            if (customEvent.defaultPrevented) {\n                throw new Error(`Blocked remote.require('${moduleName}')`);\n            }\n            else {\n                customEvent.returnValue = process.mainModule.require(moduleName);\n            }\n        }\n        return valueToMeta(event.sender, contextId, customEvent.returnValue);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_GET_BUILTIN\" /* BROWSER_GET_BUILTIN */, function (event, contextId, moduleName, stack) {\n        logStack(event.sender, `remote.getBuiltin('${moduleName}')`, stack);\n        const customEvent = emitCustomEvent(event.sender, 'remote-get-builtin', moduleName);\n        if (customEvent.returnValue === undefined) {\n            if (customEvent.defaultPrevented) {\n                throw new Error(`Blocked remote.getBuiltin('${moduleName}')`);\n            }\n            else {\n                customEvent.returnValue = __webpack_require__(496)[moduleName];\n            }\n        }\n        return valueToMeta(event.sender, contextId, customEvent.returnValue);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_GET_GLOBAL\" /* BROWSER_GET_GLOBAL */, function (event, contextId, globalName, stack) {\n        logStack(event.sender, `remote.getGlobal('${globalName}')`, stack);\n        const customEvent = emitCustomEvent(event.sender, 'remote-get-global', globalName);\n        if (customEvent.returnValue === undefined) {\n            if (customEvent.defaultPrevented) {\n                throw new Error(`Blocked remote.getGlobal('${globalName}')`);\n            }\n            else {\n                customEvent.returnValue = __webpack_require__.g[globalName];\n            }\n        }\n        return valueToMeta(event.sender, contextId, customEvent.returnValue);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_GET_CURRENT_WINDOW\" /* BROWSER_GET_CURRENT_WINDOW */, function (event, contextId, stack) {\n        logStack(event.sender, 'remote.getCurrentWindow()', stack);\n        const customEvent = emitCustomEvent(event.sender, 'remote-get-current-window');\n        if (customEvent.returnValue === undefined) {\n            if (customEvent.defaultPrevented) {\n                throw new Error('Blocked remote.getCurrentWindow()');\n            }\n            else {\n                customEvent.returnValue = event.sender.getOwnerBrowserWindow();\n            }\n        }\n        return valueToMeta(event.sender, contextId, customEvent.returnValue);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_GET_CURRENT_WEB_CONTENTS\" /* BROWSER_GET_CURRENT_WEB_CONTENTS */, function (event, contextId, stack) {\n        logStack(event.sender, 'remote.getCurrentWebContents()', stack);\n        const customEvent = emitCustomEvent(event.sender, 'remote-get-current-web-contents');\n        if (customEvent.returnValue === undefined) {\n            if (customEvent.defaultPrevented) {\n                throw new Error('Blocked remote.getCurrentWebContents()');\n            }\n            else {\n                customEvent.returnValue = event.sender;\n            }\n        }\n        return valueToMeta(event.sender, contextId, customEvent.returnValue);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_CONSTRUCTOR\" /* BROWSER_CONSTRUCTOR */, function (event, contextId, id, args) {\n        args = unwrapArgs(event.sender, event.frameId, contextId, args);\n        const constructor = objects_registry_1.default.get(id);\n        if (constructor == null) {\n            throwRPCError(`Cannot call constructor on missing remote object ${id}`);\n        }\n        return valueToMeta(event.sender, contextId, new constructor(...args));\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_FUNCTION_CALL\" /* BROWSER_FUNCTION_CALL */, function (event, contextId, id, args) {\n        args = unwrapArgs(event.sender, event.frameId, contextId, args);\n        const func = objects_registry_1.default.get(id);\n        if (func == null) {\n            throwRPCError(`Cannot call function on missing remote object ${id}`);\n        }\n        try {\n            return valueToMeta(event.sender, contextId, func(...args), true);\n        }\n        catch (error) {\n            const err = new Error(`Could not call remote function '${func.name || 'anonymous'}'. Check that the function signature is correct. Underlying error: ${error.message}\\nUnderlying stack: ${error.stack}\\n`);\n            err.cause = error;\n            throw err;\n        }\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_MEMBER_CONSTRUCTOR\" /* BROWSER_MEMBER_CONSTRUCTOR */, function (event, contextId, id, method, args) {\n        args = unwrapArgs(event.sender, event.frameId, contextId, args);\n        const object = objects_registry_1.default.get(id);\n        if (object == null) {\n            throwRPCError(`Cannot call constructor '${method}' on missing remote object ${id}`);\n        }\n        return valueToMeta(event.sender, contextId, new object[method](...args));\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_MEMBER_CALL\" /* BROWSER_MEMBER_CALL */, function (event, contextId, id, method, args) {\n        args = unwrapArgs(event.sender, event.frameId, contextId, args);\n        const object = objects_registry_1.default.get(id);\n        if (object == null) {\n            throwRPCError(`Cannot call method '${method}' on missing remote object ${id}`);\n        }\n        try {\n            return valueToMeta(event.sender, contextId, object[method](...args), true);\n        }\n        catch (error) {\n            const err = new Error(`Could not call remote method '${method}'. Check that the method signature is correct. Underlying error: ${error.message}\\nUnderlying stack: ${error.stack}\\n`);\n            err.cause = error;\n            throw err;\n        }\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_MEMBER_SET\" /* BROWSER_MEMBER_SET */, function (event, contextId, id, name, args) {\n        args = unwrapArgs(event.sender, event.frameId, contextId, args);\n        const obj = objects_registry_1.default.get(id);\n        if (obj == null) {\n            throwRPCError(`Cannot set property '${name}' on missing remote object ${id}`);\n        }\n        obj[name] = args[0];\n        return null;\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_MEMBER_GET\" /* BROWSER_MEMBER_GET */, function (event, contextId, id, name) {\n        const obj = objects_registry_1.default.get(id);\n        if (obj == null) {\n            throwRPCError(`Cannot get property '${name}' on missing remote object ${id}`);\n        }\n        return valueToMeta(event.sender, contextId, obj[name]);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_DEREFERENCE\" /* BROWSER_DEREFERENCE */, function (event, contextId, id) {\n        objects_registry_1.default.remove(event.sender, contextId, id);\n    });\n    handleRemoteCommand(\"REMOTE_BROWSER_CONTEXT_RELEASE\" /* BROWSER_CONTEXT_RELEASE */, (event, contextId) => {\n        objects_registry_1.default.clear(event.sender, contextId);\n        return null;\n    });\n}\nexports.initialize = initialize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsR0FBRztBQUNqRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx5QkFBeUIscUVBQXFFLGNBQWMsc0JBQXNCLFlBQVk7QUFDbk47QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU8sNkJBQTZCLEdBQUc7QUFDN0Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLDZCQUE2QixHQUFHO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsT0FBTyxtRUFBbUUsY0FBYyxzQkFBc0IsWUFBWTtBQUM3TDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSyw2QkFBNkIsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUssNkJBQTZCLEdBQUc7QUFDdkY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BjLWNvbXBhdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZWxlY3Ryb24rcmVtb3RlQDIuMC41L25vZGVfbW9kdWxlcy9AZWxlY3Ryb24vcmVtb3RlL2Rpc3Qvc3JjL21haW4vc2VydmVyLmpzPzg4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluaXRpYWxpemUgPSBleHBvcnRzLmVuYWJsZSA9IGV4cG9ydHMuaXNSZW1vdGVNb2R1bGVFbmFibGVkID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgb2JqZWN0c19yZWdpc3RyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29iamVjdHMtcmVnaXN0cnlcIikpO1xuY29uc3QgdHlwZV91dGlsc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90eXBlLXV0aWxzXCIpO1xuY29uc3QgZWxlY3Ryb25fMSA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTtcbmNvbnN0IGdldF9lbGVjdHJvbl9iaW5kaW5nXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dldC1lbGVjdHJvbi1iaW5kaW5nXCIpO1xuY29uc3QgdjhVdGlsID0gZ2V0X2VsZWN0cm9uX2JpbmRpbmdfMS5nZXRFbGVjdHJvbkJpbmRpbmcoJ3Y4X3V0aWwnKTtcbmNvbnN0IGhhc1dlYlByZWZzUmVtb3RlTW9kdWxlQVBJID0gKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGVsZWN0cm9uVmVyc2lvbiA9IE51bWJlcigoX2IgPSAoX2EgPSBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoXCIuXCIpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pO1xuICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZWxlY3Ryb25WZXJzaW9uKSB8fCBlbGVjdHJvblZlcnNpb24gPCAxNDtcbn0pKCk7XG4vLyBUaGUgaW50ZXJuYWwgcHJvcGVydGllcyBvZiBGdW5jdGlvbi5cbmNvbnN0IEZVTkNUSU9OX1BST1BFUlRJRVMgPSBbXG4gICAgJ2xlbmd0aCcsICduYW1lJywgJ2FyZ3VtZW50cycsICdjYWxsZXInLCAncHJvdG90eXBlJ1xuXTtcbi8vIFRoZSByZW1vdGUgZnVuY3Rpb25zIGluIHJlbmRlcmVyIHByb2Nlc3Nlcy5cbmNvbnN0IHJlbmRlcmVyRnVuY3Rpb25DYWNoZSA9IG5ldyBNYXAoKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuY29uc3QgZmluYWxpemF0aW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGZpKSA9PiB7XG4gICAgY29uc3QgbWFwS2V5ID0gZmkuaWRbMF0gKyAnficgKyBmaS5pZFsxXTtcbiAgICBjb25zdCByZWYgPSByZW5kZXJlckZ1bmN0aW9uQ2FjaGUuZ2V0KG1hcEtleSk7XG4gICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkICYmIHJlZi5kZXJlZigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuZGVyZXJGdW5jdGlvbkNhY2hlLmRlbGV0ZShtYXBLZXkpO1xuICAgICAgICBpZiAoIWZpLndlYkNvbnRlbnRzLmlzRGVzdHJveWVkKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmkud2ViQ29udGVudHMuc2VuZFRvRnJhbWUoZmkuZnJhbWVJZCwgXCJSRU1PVEVfUkVOREVSRVJfUkVMRUFTRV9DQUxMQkFDS1wiIC8qIFJFTkRFUkVSX1JFTEVBU0VfQ0FMTEJBQ0sgKi8sIGZpLmlkWzBdLCBmaS5pZFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHNlbmRUb0ZyYW1lKCkgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5mdW5jdGlvbiBnZXRDYWNoZWRSZW5kZXJlckZ1bmN0aW9uKGlkKSB7XG4gICAgY29uc3QgbWFwS2V5ID0gaWRbMF0gKyAnficgKyBpZFsxXTtcbiAgICBjb25zdCByZWYgPSByZW5kZXJlckZ1bmN0aW9uQ2FjaGUuZ2V0KG1hcEtleSk7XG4gICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlcmVmID0gcmVmLmRlcmVmKCk7XG4gICAgICAgIGlmIChkZXJlZiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRlcmVmO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldENhY2hlZFJlbmRlcmVyRnVuY3Rpb24oaWQsIHdjLCBmcmFtZUlkLCB2YWx1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGNvbnN0IHdyID0gbmV3IFdlYWtSZWYodmFsdWUpO1xuICAgIGNvbnN0IG1hcEtleSA9IGlkWzBdICsgJ34nICsgaWRbMV07XG4gICAgcmVuZGVyZXJGdW5jdGlvbkNhY2hlLnNldChtYXBLZXksIHdyKTtcbiAgICBmaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3Rlcih2YWx1ZSwge1xuICAgICAgICBpZCxcbiAgICAgICAgd2ViQ29udGVudHM6IHdjLFxuICAgICAgICBmcmFtZUlkXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbG9jYXRpb25JbmZvID0gbmV3IFdlYWtNYXAoKTtcbi8vIFJldHVybiB0aGUgZGVzY3JpcHRpb24gb2Ygb2JqZWN0J3MgbWVtYmVyczpcbmNvbnN0IGdldE9iamVjdE1lbWJlcnMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgbGV0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbiAgICAvLyBGb3IgRnVuY3Rpb24sIHdlIHNob3VsZCBub3Qgb3ZlcnJpZGUgZm9sbG93aW5nIHByb3BlcnRpZXMgZXZlbiB0aG91Z2ggdGhleVxuICAgIC8vIGFyZSBcIm93blwiIHByb3BlcnRpZXMuXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbmFtZXMgPSBuYW1lcy5maWx0ZXIoKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhRlVOQ1RJT05fUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE1hcCBwcm9wZXJ0aWVzIHRvIGRlc2NyaXB0b3JzLlxuICAgIHJldHVybiBuYW1lcy5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGxldCB3cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2JqZWN0W25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0eXBlID0gJ21ldGhvZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAgICAgICAgICAgICB3cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0eXBlID0gJ2dldCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLCB3cml0YWJsZSwgdHlwZSB9O1xuICAgIH0pO1xufTtcbi8vIFJldHVybiB0aGUgZGVzY3JpcHRpb24gb2Ygb2JqZWN0J3MgcHJvdG90eXBlLlxuY29uc3QgZ2V0T2JqZWN0UHJvdG90eXBlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKHByb3RvID09PSBudWxsIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZW1iZXJzOiBnZXRPYmplY3RNZW1iZXJzKHByb3RvKSxcbiAgICAgICAgcHJvdG86IGdldE9iamVjdFByb3RvdHlwZShwcm90bylcbiAgICB9O1xufTtcbi8vIENvbnZlcnQgYSByZWFsIHZhbHVlIGludG8gbWV0YSBkYXRhLlxuY29uc3QgdmFsdWVUb01ldGEgPSBmdW5jdGlvbiAoc2VuZGVyLCBjb250ZXh0SWQsIHZhbHVlLCBvcHRpbWl6ZVNpbXBsZU9iamVjdCA9IGZhbHNlKSB7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHZhbHVlLlxuICAgIGxldCB0eXBlO1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAvLyBSZWNvZ25pemUgY2VydGFpbiB0eXBlcyBvZiBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gJ05hdGl2ZUltYWdlJykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnbmF0aXZlaW1hZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2Vycm9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVfdXRpbHNfMS5pc1NlcmlhbGl6YWJsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ZhbHVlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVfdXRpbHNfMS5pc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdwcm9taXNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmIHZhbHVlLmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgdGhlIGFyZ3VtZW50cyBvYmplY3QgYXMgYXJyYXkuXG4gICAgICAgICAgICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpbWl6ZVNpbXBsZU9iamVjdCAmJiB2OFV0aWwuZ2V0SGlkZGVuVmFsdWUodmFsdWUsICdzaW1wbGUnKSkge1xuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHNpbXBsZSBvYmplY3RzIGFzIHZhbHVlLlxuICAgICAgICAgICAgICAgIHR5cGUgPSAndmFsdWUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0eXBlID0gJ3ZhbHVlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBGaWxsIHRoZSBtZXRhIG9iamVjdCBhY2NvcmRpbmcgdG8gdmFsdWUncyB0eXBlLlxuICAgIGlmICh0eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVtYmVyczogdmFsdWUubWFwKChlbCkgPT4gdmFsdWVUb01ldGEoc2VuZGVyLCBjb250ZXh0SWQsIGVsLCBvcHRpbWl6ZVNpbXBsZU9iamVjdCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICduYXRpdmVpbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZSwgdmFsdWU6IHR5cGVfdXRpbHNfMS5zZXJpYWxpemUodmFsdWUpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBuYW1lOiB2YWx1ZS5jb25zdHJ1Y3RvciA/IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiAnJyxcbiAgICAgICAgICAgIC8vIFJlZmVyZW5jZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgaXQncyBhbiBvYmplY3QsIGJlY2F1c2Ugd2hlbiBpdCdzXG4gICAgICAgICAgICAvLyBwYXNzZWQgdG8gcmVuZGVyZXIgd2Ugd291bGQgYXNzdW1lIHRoZSByZW5kZXJlciBrZWVwcyBhIHJlZmVyZW5jZSBvZlxuICAgICAgICAgICAgLy8gaXQuXG4gICAgICAgICAgICBpZDogb2JqZWN0c19yZWdpc3RyeV8xLmRlZmF1bHQuYWRkKHNlbmRlciwgY29udGV4dElkLCB2YWx1ZSksXG4gICAgICAgICAgICBtZW1iZXJzOiBnZXRPYmplY3RNZW1iZXJzKHZhbHVlKSxcbiAgICAgICAgICAgIHByb3RvOiBnZXRPYmplY3RQcm90b3R5cGUodmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdidWZmZXInKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGUsIHZhbHVlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdwcm9taXNlJykge1xuICAgICAgICAvLyBBZGQgZGVmYXVsdCBoYW5kbGVyIHRvIHByZXZlbnQgdW5oYW5kbGVkIHJlamVjdGlvbnMgaW4gbWFpbiBwcm9jZXNzXG4gICAgICAgIC8vIEluc3RlYWQgdGhleSBzaG91bGQgYXBwZWFyIGluIHRoZSByZW5kZXJlciBwcm9jZXNzXG4gICAgICAgIHZhbHVlLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHRoZW46IHZhbHVlVG9NZXRhKHNlbmRlciwgY29udGV4dElkLCBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lbWJlcnM6IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAobmFtZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVG9NZXRhKHNlbmRlciwgY29udGV4dElkLCB2YWx1ZVtuYW1lXSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd2YWx1ZScsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCB0aHJvd1JQQ0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5jb2RlID0gJ0VCQURSUEMnO1xuICAgIGVycm9yLmVycm5vID0gLTcyO1xuICAgIHRocm93IGVycm9yO1xufTtcbmNvbnN0IHJlbW92ZVJlbW90ZUxpc3RlbmVyc0FuZExvZ1dhcm5pbmcgPSAoc2VuZGVyLCBjYWxsSW50b1JlbmRlcmVyKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGlvbkluZm8uZ2V0KGNhbGxJbnRvUmVuZGVyZXIpO1xuICAgIGxldCBtZXNzYWdlID0gJ0F0dGVtcHRpbmcgdG8gY2FsbCBhIGZ1bmN0aW9uIGluIGEgcmVuZGVyZXIgd2luZG93IHRoYXQgaGFzIGJlZW4gY2xvc2VkIG9yIHJlbGVhc2VkLicgK1xuICAgICAgICBgXFxuRnVuY3Rpb24gcHJvdmlkZWQgaGVyZTogJHtsb2NhdGlvbn1gO1xuICAgIGlmIChzZW5kZXIgaW5zdGFuY2VvZiBldmVudHNfMS5FdmVudEVtaXR0ZXIpIHtcbiAgICAgICAgY29uc3QgcmVtb3RlRXZlbnRzID0gc2VuZGVyLmV2ZW50TmFtZXMoKS5maWx0ZXIoKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRlci5saXN0ZW5lcnMoZXZlbnROYW1lKS5pbmNsdWRlcyhjYWxsSW50b1JlbmRlcmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZW1vdGVFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgXFxuUmVtb3RlIGV2ZW50IG5hbWVzOiAke3JlbW90ZUV2ZW50cy5qb2luKCcsICcpfWA7XG4gICAgICAgICAgICByZW1vdGVFdmVudHMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VuZGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbEludG9SZW5kZXJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59O1xuY29uc3QgZmFrZUNvbnN0cnVjdG9yID0gKGNvbnN0cnVjdG9yLCBuYW1lKSA9PiBuZXcgUHJveHkoT2JqZWN0LCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICduYW1lJykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8vIENvbnZlcnQgYXJyYXkgb2YgbWV0YSBkYXRhIGZyb20gcmVuZGVyZXIgaW50byBhcnJheSBvZiByZWFsIHZhbHVlcy5cbmNvbnN0IHVud3JhcEFyZ3MgPSBmdW5jdGlvbiAoc2VuZGVyLCBmcmFtZUlkLCBjb250ZXh0SWQsIGFyZ3MpIHtcbiAgICBjb25zdCBtZXRhVG9WYWx1ZSA9IGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIHN3aXRjaCAobWV0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduYXRpdmVpbWFnZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVfdXRpbHNfMS5kZXNlcmlhbGl6ZShtZXRhLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ3JlbW90ZS1vYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RzX3JlZ2lzdHJ5XzEuZGVmYXVsdC5nZXQobWV0YS5pZCk7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcEFyZ3Moc2VuZGVyLCBmcmFtZUlkLCBjb250ZXh0SWQsIG1ldGEudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obWV0YS52YWx1ZS5idWZmZXIsIG1ldGEudmFsdWUuYnl0ZU9mZnNldCwgbWV0YS52YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Byb21pc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICB0aGVuOiBtZXRhVG9WYWx1ZShtZXRhLnRoZW4pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gbWV0YS5uYW1lICE9PSAnT2JqZWN0JyA/IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogZmFrZUNvbnN0cnVjdG9yKE9iamVjdCwgbWV0YS5uYW1lKVxuICAgICAgICAgICAgICAgIH0pIDoge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgbWV0YS5tZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtuYW1lXSA9IG1ldGFUb1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uLXdpdGgtcmV0dXJuLXZhbHVlJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gbWV0YVRvVmFsdWUobWV0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBjb250ZXh0SWQgYW5kIG1ldGEuaWQsIHNpbmNlIG1ldGEuaWQgY2FuIGJlIHRoZSBzYW1lIGluXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IHdlYkNvbnRlbnRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdElkID0gW2NvbnRleHRJZCwgbWV0YS5pZF07XG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGNhbGxiYWNrcyBpbiByZW5kZXJlci5cbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRGdW5jdGlvbiA9IGdldENhY2hlZFJlbmRlcmVyRnVuY3Rpb24ob2JqZWN0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRGdW5jdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEludG9SZW5kZXJlciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWNjZWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VuZGVyLmlzRGVzdHJveWVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VlZCA9IHNlbmRlci5zZW5kVG9GcmFtZShmcmFtZUlkLCBcIlJFTU9URV9SRU5ERVJFUl9DQUxMQkFDS1wiIC8qIFJFTkRFUkVSX0NBTExCQUNLICovLCBjb250ZXh0SWQsIG1ldGEuaWQsIHZhbHVlVG9NZXRhKHNlbmRlciwgY29udGV4dElkLCBhcmdzKSkgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBzZW5kVG9GcmFtZSgpIGZhaWxlZDogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2NlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlbW90ZUxpc3RlbmVyc0FuZExvZ1dhcm5pbmcodGhpcywgY2FsbEludG9SZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uSW5mby5zZXQoY2FsbEludG9SZW5kZXJlciwgbWV0YS5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxJbnRvUmVuZGVyZXIsICdsZW5ndGgnLCB7IHZhbHVlOiBtZXRhLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICBzZXRDYWNoZWRSZW5kZXJlckZ1bmN0aW9uKG9iamVjdElkLCBzZW5kZXIsIGZyYW1lSWQsIGNhbGxJbnRvUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsSW50b1JlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIHR5cGU6ICR7bWV0YS50eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXJncy5tYXAobWV0YVRvVmFsdWUpO1xufTtcbmNvbnN0IGlzUmVtb3RlTW9kdWxlRW5hYmxlZEltcGwgPSBmdW5jdGlvbiAoY29udGVudHMpIHtcbiAgICBjb25zdCB3ZWJQcmVmZXJlbmNlcyA9IGNvbnRlbnRzLmdldExhc3RXZWJQcmVmZXJlbmNlcygpIHx8IHt9O1xuICAgIHJldHVybiB3ZWJQcmVmZXJlbmNlcy5lbmFibGVSZW1vdGVNb2R1bGUgIT0gbnVsbCA/ICEhd2ViUHJlZmVyZW5jZXMuZW5hYmxlUmVtb3RlTW9kdWxlIDogZmFsc2U7XG59O1xuY29uc3QgaXNSZW1vdGVNb2R1bGVFbmFibGVkQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgaXNSZW1vdGVNb2R1bGVFbmFibGVkID0gZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gICAgaWYgKGhhc1dlYlByZWZzUmVtb3RlTW9kdWxlQVBJICYmICFpc1JlbW90ZU1vZHVsZUVuYWJsZWRDYWNoZS5oYXMoY29udGVudHMpKSB7XG4gICAgICAgIGlzUmVtb3RlTW9kdWxlRW5hYmxlZENhY2hlLnNldChjb250ZW50cywgaXNSZW1vdGVNb2R1bGVFbmFibGVkSW1wbChjb250ZW50cykpO1xuICAgIH1cbiAgICByZXR1cm4gaXNSZW1vdGVNb2R1bGVFbmFibGVkQ2FjaGUuZ2V0KGNvbnRlbnRzKTtcbn07XG5leHBvcnRzLmlzUmVtb3RlTW9kdWxlRW5hYmxlZCA9IGlzUmVtb3RlTW9kdWxlRW5hYmxlZDtcbmZ1bmN0aW9uIGVuYWJsZShjb250ZW50cykge1xuICAgIGlzUmVtb3RlTW9kdWxlRW5hYmxlZENhY2hlLnNldChjb250ZW50cywgdHJ1ZSk7XG59XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmNvbnN0IGhhbmRsZVJlbW90ZUNvbW1hbmQgPSBmdW5jdGlvbiAoY2hhbm5lbCwgaGFuZGxlcikge1xuICAgIGVsZWN0cm9uXzEuaXBjTWFpbi5vbihjaGFubmVsLCAoZXZlbnQsIGNvbnRleHRJZCwgLi4uYXJncykgPT4ge1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIGlmICghZXhwb3J0cy5pc1JlbW90ZU1vZHVsZUVuYWJsZWQoZXZlbnQuc2VuZGVyKSkge1xuICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2VwdGlvbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVG9NZXRhKGV2ZW50LnNlbmRlciwgY29udGV4dElkLCBuZXcgRXJyb3IoJ0BlbGVjdHJvbi9yZW1vdGUgaXMgZGlzYWJsZWQgZm9yIHRoaXMgV2ViQ29udGVudHMuIENhbGwgcmVxdWlyZShcIkBlbGVjdHJvbi9yZW1vdGUvbWFpblwiKS5lbmFibGUod2ViQ29udGVudHMpIHRvIGVuYWJsZSBpdC4nKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gaGFuZGxlcihldmVudCwgY29udGV4dElkLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdleGNlcHRpb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVRvTWV0YShldmVudC5zZW5kZXIsIGNvbnRleHRJZCwgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0dXJuVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IGVtaXRDdXN0b21FdmVudCA9IGZ1bmN0aW9uIChjb250ZW50cywgZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7IHNlbmRlcjogY29udGVudHMsIHJldHVyblZhbHVlOiB1bmRlZmluZWQsIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlIH07XG4gICAgZWxlY3Ryb25fMS5hcHAuZW1pdChldmVudE5hbWUsIGV2ZW50LCBjb250ZW50cywgLi4uYXJncyk7XG4gICAgY29udGVudHMuZW1pdChldmVudE5hbWUsIGV2ZW50LCAuLi5hcmdzKTtcbiAgICByZXR1cm4gZXZlbnQ7XG59O1xuY29uc3QgbG9nU3RhY2sgPSBmdW5jdGlvbiAoY29udGVudHMsIGNvZGUsIHN0YWNrKSB7XG4gICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgV2ViQ29udGVudHMgKCR7Y29udGVudHMuaWR9KTogJHtjb2RlfWAsIHN0YWNrKTtcbiAgICB9XG59O1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmIChpbml0aWFsaXplZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAZWxlY3Ryb24vcmVtb3RlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgaGFuZGxlUmVtb3RlQ29tbWFuZChcIlJFTU9URV9CUk9XU0VSX1dST05HX0NPTlRFWFRfRVJST1JcIiAvKiBCUk9XU0VSX1dST05HX0NPTlRFWFRfRVJST1IgKi8sIGZ1bmN0aW9uIChldmVudCwgY29udGV4dElkLCBwYXNzZWRDb250ZXh0SWQsIGlkKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdElkID0gW3Bhc3NlZENvbnRleHRJZCwgaWRdO1xuICAgICAgICBjb25zdCBjYWNoZWRGdW5jdGlvbiA9IGdldENhY2hlZFJlbmRlcmVyRnVuY3Rpb24ob2JqZWN0SWQpO1xuICAgICAgICBpZiAoY2FjaGVkRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgZXJyb3IgaGFzIGFscmVhZHkgYmVlbiByZXBvcnRlZCBiZWZvcmUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlUmVtb3RlTGlzdGVuZXJzQW5kTG9nV2FybmluZyhldmVudC5zZW5kZXIsIGNhY2hlZEZ1bmN0aW9uKTtcbiAgICB9KTtcbiAgICBoYW5kbGVSZW1vdGVDb21tYW5kKFwiUkVNT1RFX0JST1dTRVJfUkVRVUlSRVwiIC8qIEJST1dTRVJfUkVRVUlSRSAqLywgZnVuY3Rpb24gKGV2ZW50LCBjb250ZXh0SWQsIG1vZHVsZU5hbWUsIHN0YWNrKSB7XG4gICAgICAgIGxvZ1N0YWNrKGV2ZW50LnNlbmRlciwgYHJlbW90ZS5yZXF1aXJlKCcke21vZHVsZU5hbWV9JylgLCBzdGFjayk7XG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gZW1pdEN1c3RvbUV2ZW50KGV2ZW50LnNlbmRlciwgJ3JlbW90ZS1yZXF1aXJlJywgbW9kdWxlTmFtZSk7XG4gICAgICAgIGlmIChjdXN0b21FdmVudC5yZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2tlZCByZW1vdGUucmVxdWlyZSgnJHttb2R1bGVOYW1lfScpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC5yZXR1cm5WYWx1ZSA9IHByb2Nlc3MubWFpbk1vZHVsZS5yZXF1aXJlKG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVRvTWV0YShldmVudC5zZW5kZXIsIGNvbnRleHRJZCwgY3VzdG9tRXZlbnQucmV0dXJuVmFsdWUpO1xuICAgIH0pO1xuICAgIGhhbmRsZVJlbW90ZUNvbW1hbmQoXCJSRU1PVEVfQlJPV1NFUl9HRVRfQlVJTFRJTlwiIC8qIEJST1dTRVJfR0VUX0JVSUxUSU4gKi8sIGZ1bmN0aW9uIChldmVudCwgY29udGV4dElkLCBtb2R1bGVOYW1lLCBzdGFjaykge1xuICAgICAgICBsb2dTdGFjayhldmVudC5zZW5kZXIsIGByZW1vdGUuZ2V0QnVpbHRpbignJHttb2R1bGVOYW1lfScpYCwgc3RhY2spO1xuICAgICAgICBjb25zdCBjdXN0b21FdmVudCA9IGVtaXRDdXN0b21FdmVudChldmVudC5zZW5kZXIsICdyZW1vdGUtZ2V0LWJ1aWx0aW4nLCBtb2R1bGVOYW1lKTtcbiAgICAgICAgaWYgKGN1c3RvbUV2ZW50LnJldHVyblZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9ja2VkIHJlbW90ZS5nZXRCdWlsdGluKCcke21vZHVsZU5hbWV9JylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LnJldHVyblZhbHVlID0gcmVxdWlyZSgnZWxlY3Ryb24nKVttb2R1bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVUb01ldGEoZXZlbnQuc2VuZGVyLCBjb250ZXh0SWQsIGN1c3RvbUV2ZW50LnJldHVyblZhbHVlKTtcbiAgICB9KTtcbiAgICBoYW5kbGVSZW1vdGVDb21tYW5kKFwiUkVNT1RFX0JST1dTRVJfR0VUX0dMT0JBTFwiIC8qIEJST1dTRVJfR0VUX0dMT0JBTCAqLywgZnVuY3Rpb24gKGV2ZW50LCBjb250ZXh0SWQsIGdsb2JhbE5hbWUsIHN0YWNrKSB7XG4gICAgICAgIGxvZ1N0YWNrKGV2ZW50LnNlbmRlciwgYHJlbW90ZS5nZXRHbG9iYWwoJyR7Z2xvYmFsTmFtZX0nKWAsIHN0YWNrKTtcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSBlbWl0Q3VzdG9tRXZlbnQoZXZlbnQuc2VuZGVyLCAncmVtb3RlLWdldC1nbG9iYWwnLCBnbG9iYWxOYW1lKTtcbiAgICAgICAgaWYgKGN1c3RvbUV2ZW50LnJldHVyblZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9ja2VkIHJlbW90ZS5nZXRHbG9iYWwoJyR7Z2xvYmFsTmFtZX0nKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQucmV0dXJuVmFsdWUgPSBnbG9iYWxbZ2xvYmFsTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlVG9NZXRhKGV2ZW50LnNlbmRlciwgY29udGV4dElkLCBjdXN0b21FdmVudC5yZXR1cm5WYWx1ZSk7XG4gICAgfSk7XG4gICAgaGFuZGxlUmVtb3RlQ29tbWFuZChcIlJFTU9URV9CUk9XU0VSX0dFVF9DVVJSRU5UX1dJTkRPV1wiIC8qIEJST1dTRVJfR0VUX0NVUlJFTlRfV0lORE9XICovLCBmdW5jdGlvbiAoZXZlbnQsIGNvbnRleHRJZCwgc3RhY2spIHtcbiAgICAgICAgbG9nU3RhY2soZXZlbnQuc2VuZGVyLCAncmVtb3RlLmdldEN1cnJlbnRXaW5kb3coKScsIHN0YWNrKTtcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSBlbWl0Q3VzdG9tRXZlbnQoZXZlbnQuc2VuZGVyLCAncmVtb3RlLWdldC1jdXJyZW50LXdpbmRvdycpO1xuICAgICAgICBpZiAoY3VzdG9tRXZlbnQucmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrZWQgcmVtb3RlLmdldEN1cnJlbnRXaW5kb3coKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5zZW5kZXIuZ2V0T3duZXJCcm93c2VyV2luZG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlVG9NZXRhKGV2ZW50LnNlbmRlciwgY29udGV4dElkLCBjdXN0b21FdmVudC5yZXR1cm5WYWx1ZSk7XG4gICAgfSk7XG4gICAgaGFuZGxlUmVtb3RlQ29tbWFuZChcIlJFTU9URV9CUk9XU0VSX0dFVF9DVVJSRU5UX1dFQl9DT05URU5UU1wiIC8qIEJST1dTRVJfR0VUX0NVUlJFTlRfV0VCX0NPTlRFTlRTICovLCBmdW5jdGlvbiAoZXZlbnQsIGNvbnRleHRJZCwgc3RhY2spIHtcbiAgICAgICAgbG9nU3RhY2soZXZlbnQuc2VuZGVyLCAncmVtb3RlLmdldEN1cnJlbnRXZWJDb250ZW50cygpJywgc3RhY2spO1xuICAgICAgICBjb25zdCBjdXN0b21FdmVudCA9IGVtaXRDdXN0b21FdmVudChldmVudC5zZW5kZXIsICdyZW1vdGUtZ2V0LWN1cnJlbnQtd2ViLWNvbnRlbnRzJyk7XG4gICAgICAgIGlmIChjdXN0b21FdmVudC5yZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2tlZCByZW1vdGUuZ2V0Q3VycmVudFdlYkNvbnRlbnRzKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQuc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVRvTWV0YShldmVudC5zZW5kZXIsIGNvbnRleHRJZCwgY3VzdG9tRXZlbnQucmV0dXJuVmFsdWUpO1xuICAgIH0pO1xuICAgIGhhbmRsZVJlbW90ZUNvbW1hbmQoXCJSRU1PVEVfQlJPV1NFUl9DT05TVFJVQ1RPUlwiIC8qIEJST1dTRVJfQ09OU1RSVUNUT1IgKi8sIGZ1bmN0aW9uIChldmVudCwgY29udGV4dElkLCBpZCwgYXJncykge1xuICAgICAgICBhcmdzID0gdW53cmFwQXJncyhldmVudC5zZW5kZXIsIGV2ZW50LmZyYW1lSWQsIGNvbnRleHRJZCwgYXJncyk7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gb2JqZWN0c19yZWdpc3RyeV8xLmRlZmF1bHQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93UlBDRXJyb3IoYENhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIG9uIG1pc3NpbmcgcmVtb3RlIG9iamVjdCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVRvTWV0YShldmVudC5zZW5kZXIsIGNvbnRleHRJZCwgbmV3IGNvbnN0cnVjdG9yKC4uLmFyZ3MpKTtcbiAgICB9KTtcbiAgICBoYW5kbGVSZW1vdGVDb21tYW5kKFwiUkVNT1RFX0JST1dTRVJfRlVOQ1RJT05fQ0FMTFwiIC8qIEJST1dTRVJfRlVOQ1RJT05fQ0FMTCAqLywgZnVuY3Rpb24gKGV2ZW50LCBjb250ZXh0SWQsIGlkLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB1bndyYXBBcmdzKGV2ZW50LnNlbmRlciwgZXZlbnQuZnJhbWVJZCwgY29udGV4dElkLCBhcmdzKTtcbiAgICAgICAgY29uc3QgZnVuYyA9IG9iamVjdHNfcmVnaXN0cnlfMS5kZWZhdWx0LmdldChpZCk7XG4gICAgICAgIGlmIChmdW5jID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93UlBDRXJyb3IoYENhbm5vdCBjYWxsIGZ1bmN0aW9uIG9uIG1pc3NpbmcgcmVtb3RlIG9iamVjdCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUb01ldGEoZXZlbnQuc2VuZGVyLCBjb250ZXh0SWQsIGZ1bmMoLi4uYXJncyksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDb3VsZCBub3QgY2FsbCByZW1vdGUgZnVuY3Rpb24gJyR7ZnVuYy5uYW1lIHx8ICdhbm9ueW1vdXMnfScuIENoZWNrIHRoYXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBpcyBjb3JyZWN0LiBVbmRlcmx5aW5nIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9XFxuVW5kZXJseWluZyBzdGFjazogJHtlcnJvci5zdGFja31cXG5gKTtcbiAgICAgICAgICAgIGVyci5jYXVzZSA9IGVycm9yO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaGFuZGxlUmVtb3RlQ29tbWFuZChcIlJFTU9URV9CUk9XU0VSX01FTUJFUl9DT05TVFJVQ1RPUlwiIC8qIEJST1dTRVJfTUVNQkVSX0NPTlNUUlVDVE9SICovLCBmdW5jdGlvbiAoZXZlbnQsIGNvbnRleHRJZCwgaWQsIG1ldGhvZCwgYXJncykge1xuICAgICAgICBhcmdzID0gdW53cmFwQXJncyhldmVudC5zZW5kZXIsIGV2ZW50LmZyYW1lSWQsIGNvbnRleHRJZCwgYXJncyk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IG9iamVjdHNfcmVnaXN0cnlfMS5kZWZhdWx0LmdldChpZCk7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dSUENFcnJvcihgQ2Fubm90IGNhbGwgY29uc3RydWN0b3IgJyR7bWV0aG9kfScgb24gbWlzc2luZyByZW1vdGUgb2JqZWN0ICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlVG9NZXRhKGV2ZW50LnNlbmRlciwgY29udGV4dElkLCBuZXcgb2JqZWN0W21ldGhvZF0oLi4uYXJncykpO1xuICAgIH0pO1xuICAgIGhhbmRsZVJlbW90ZUNvbW1hbmQoXCJSRU1PVEVfQlJPV1NFUl9NRU1CRVJfQ0FMTFwiIC8qIEJST1dTRVJfTUVNQkVSX0NBTEwgKi8sIGZ1bmN0aW9uIChldmVudCwgY29udGV4dElkLCBpZCwgbWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB1bndyYXBBcmdzKGV2ZW50LnNlbmRlciwgZXZlbnQuZnJhbWVJZCwgY29udGV4dElkLCBhcmdzKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gb2JqZWN0c19yZWdpc3RyeV8xLmRlZmF1bHQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd1JQQ0Vycm9yKGBDYW5ub3QgY2FsbCBtZXRob2QgJyR7bWV0aG9kfScgb24gbWlzc2luZyByZW1vdGUgb2JqZWN0ICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvTWV0YShldmVudC5zZW5kZXIsIGNvbnRleHRJZCwgb2JqZWN0W21ldGhvZF0oLi4uYXJncyksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDb3VsZCBub3QgY2FsbCByZW1vdGUgbWV0aG9kICcke21ldGhvZH0nLiBDaGVjayB0aGF0IHRoZSBtZXRob2Qgc2lnbmF0dXJlIGlzIGNvcnJlY3QuIFVuZGVybHlpbmcgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1cXG5VbmRlcmx5aW5nIHN0YWNrOiAke2Vycm9yLnN0YWNrfVxcbmApO1xuICAgICAgICAgICAgZXJyLmNhdXNlID0gZXJyb3I7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBoYW5kbGVSZW1vdGVDb21tYW5kKFwiUkVNT1RFX0JST1dTRVJfTUVNQkVSX1NFVFwiIC8qIEJST1dTRVJfTUVNQkVSX1NFVCAqLywgZnVuY3Rpb24gKGV2ZW50LCBjb250ZXh0SWQsIGlkLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB1bndyYXBBcmdzKGV2ZW50LnNlbmRlciwgZXZlbnQuZnJhbWVJZCwgY29udGV4dElkLCBhcmdzKTtcbiAgICAgICAgY29uc3Qgb2JqID0gb2JqZWN0c19yZWdpc3RyeV8xLmRlZmF1bHQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd1JQQ0Vycm9yKGBDYW5ub3Qgc2V0IHByb3BlcnR5ICcke25hbWV9JyBvbiBtaXNzaW5nIHJlbW90ZSBvYmplY3QgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbbmFtZV0gPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBoYW5kbGVSZW1vdGVDb21tYW5kKFwiUkVNT1RFX0JST1dTRVJfTUVNQkVSX0dFVFwiIC8qIEJST1dTRVJfTUVNQkVSX0dFVCAqLywgZnVuY3Rpb24gKGV2ZW50LCBjb250ZXh0SWQsIGlkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG9iamVjdHNfcmVnaXN0cnlfMS5kZWZhdWx0LmdldChpZCk7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dSUENFcnJvcihgQ2Fubm90IGdldCBwcm9wZXJ0eSAnJHtuYW1lfScgb24gbWlzc2luZyByZW1vdGUgb2JqZWN0ICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlVG9NZXRhKGV2ZW50LnNlbmRlciwgY29udGV4dElkLCBvYmpbbmFtZV0pO1xuICAgIH0pO1xuICAgIGhhbmRsZVJlbW90ZUNvbW1hbmQoXCJSRU1PVEVfQlJPV1NFUl9ERVJFRkVSRU5DRVwiIC8qIEJST1dTRVJfREVSRUZFUkVOQ0UgKi8sIGZ1bmN0aW9uIChldmVudCwgY29udGV4dElkLCBpZCkge1xuICAgICAgICBvYmplY3RzX3JlZ2lzdHJ5XzEuZGVmYXVsdC5yZW1vdmUoZXZlbnQuc2VuZGVyLCBjb250ZXh0SWQsIGlkKTtcbiAgICB9KTtcbiAgICBoYW5kbGVSZW1vdGVDb21tYW5kKFwiUkVNT1RFX0JST1dTRVJfQ09OVEVYVF9SRUxFQVNFXCIgLyogQlJPV1NFUl9DT05URVhUX1JFTEVBU0UgKi8sIChldmVudCwgY29udGV4dElkKSA9PiB7XG4gICAgICAgIG9iamVjdHNfcmVnaXN0cnlfMS5kZWZhdWx0LmNsZWFyKGV2ZW50LnNlbmRlciwgY29udGV4dElkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG59XG5leHBvcnRzLmluaXRpYWxpemUgPSBpbml0aWFsaXplO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///118\n")},495:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = __webpack_require__(820)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk1LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BjLWNvbXBhdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZWxlY3Ryb24rcmVtb3RlQDIuMC41L25vZGVfbW9kdWxlcy9AZWxlY3Ryb24vcmVtb3RlL21haW4vaW5kZXguanM/YjM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3Qvc3JjL21haW4nKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///495\n")},100:module=>{eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYy1jb21wYXQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzQDMuMy4wL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzPzE2YjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n")},469:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n;// CONCATENATED MODULE: external "module"\nconst external_module_namespaceObject = require("module");\nvar external_module_default = /*#__PURE__*/__webpack_require__.n(external_module_namespaceObject);\n;// CONCATENATED MODULE: external "path"\nconst external_path_namespaceObject = require("path");\nvar external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_namespaceObject);\n;// CONCATENATED MODULE: external "inspector"\nconst external_inspector_namespaceObject = require("inspector");\n;// CONCATENATED MODULE: ./src/main/debug.ts\nif(process.argv.join("").includes("--debug")){(0,external_inspector_namespaceObject.open)();(0,external_inspector_namespaceObject.waitForDebugger)()}\n;// CONCATENATED MODULE: external "sucrase"\nconst external_sucrase_namespaceObject = require("sucrase");\nvar external_sucrase_default = /*#__PURE__*/__webpack_require__.n(external_sucrase_namespaceObject);\n;// CONCATENATED MODULE: external "sass"\nconst external_sass_namespaceObject = require("sass");\nvar external_sass_default = /*#__PURE__*/__webpack_require__.n(external_sass_namespaceObject);\n// EXTERNAL MODULE: external "electron"\nvar external_electron_ = __webpack_require__(496);\n;// CONCATENATED MODULE: ./src/common/ipcevents.ts\nconst MAIN_EVENT="pccompat-main-event";const COMPILE_SASS="pccompat-compile-sass";const COMPILE_JSX="pccompat-compile-jsx";const GET_APP_PATH="pccompat-get-app-path";const SET_DEV_TOOLS="pccompat-open-devtools";const GET_WINDOW_DATA="pccompat-get-window-data";const EXPOSE_PROCESS_GLOBAL="pccompat-expose-process-global";const HANDLE_CALLBACK="pccompat-handle-callback"\n;// CONCATENATED MODULE: external "fs"\nconst external_fs_namespaceObject = require("fs");\nvar external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_namespaceObject);\n;// CONCATENATED MODULE: ./src/main/events.ts\nexternal_electron_.ipcMain.on(GET_APP_PATH,event=>{event.returnValue=external_electron_.app.getAppPath()});external_electron_.ipcMain.on(GET_WINDOW_DATA,event=>{event.returnValue=event.sender.kernelWindowData});external_electron_.ipcMain.on(COMPILE_SASS,(event,file)=>{let result="";try{let abc=external_sass_default().renderSync({file});result=abc.css.toString()}catch(error){console.error(error)}event.returnValue=result});external_electron_.ipcMain.on(COMPILE_JSX,(event,file)=>{if(!external_fs_default().existsSync(file)){event.returnValue="";return}const filecontent=external_fs_default().readFileSync(file,"utf8");const{code}=external_sucrase_default().transform(filecontent,{transforms:["jsx","imports","typescript"],filePath:file});event.returnValue=code});external_electron_.ipcMain.handle(SET_DEV_TOOLS,(event,value)=>{const win=external_electron_.BrowserWindow.fromWebContents(event.sender);if(!win)return;if(value&&!win.webContents.isDevToolsOpened()){win.webContents.openDevTools()}else{win.webContents.closeDevTools()}})\n// EXTERNAL MODULE: ./node_modules/.pnpm/@electron+remote@2.0.5/node_modules/@electron/remote/main/index.js\nvar main = __webpack_require__(495);\n;// CONCATENATED MODULE: ./src/main/initRemote.ts\n(0,main.initialize)();const enableRemoteModule=function(webContents1){console.log("[Powercord] Enabling remote module for",webContents1.id);(0,main.enable)(webContents1)};for(const{webContents}of external_electron_.BrowserWindow.getAllWindows()){enableRemoteModule(webContents)}external_electron_.app.on("browser-window-created",(_,{webContents:webContents2})=>{enableRemoteModule(webContents2)})\n;// CONCATENATED MODULE: ./src/main/index.ts\nexternal_module_default().globalPaths.push(external_path_default().resolve(__dirname,"..","..","node_modules"));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxPQUNyRSxDQUFDTyxHQUFHLENBQUMsQ0FBd0Msd0NBQUVQLFlBQVcsQ0FBQ1EsRUFBRSxFQUVwRUosZUFBTSxDQUFDSixZQUFXLENBQ3RCLENBQUMsQ0FFRCxHQUFHLENBQUUsS0FBSyxDQUFFQSxXQUFXLENBQUMsR0FBSTVCLDhDQUEyQixHQUFJLENBQUMsa0JBQ3RDLENBQUM0QixXQUFXLENBQ2xDLENBQUMseUJBRUssQ0FBQyxDQUF3Qix5QkFBR1UsQ0FBQyxDQUFFLENBQUNWLFdBQVcsQ0FBWEEsWUFBVyxDQUFDLEdBQUssQ0FBQyxrQkFDbEMsQ0FBQ0EsWUFBVyxDQUNsQyxDQUFDLEM7O0FDYkRXLDBDQUF1QixDQUFDQywrQkFBWSxDQUFDSSxTQUFTLENBQUUsQ0FBSSxJQUFFLENBQUksSUFBRSxDQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGMtY29tcGF0L2V4dGVybmFsIGNvbW1vbmpzIFwibW9kdWxlXCI/NzY4MSIsIndlYnBhY2s6Ly9wYy1jb21wYXQvZXh0ZXJuYWwgY29tbW9uanMgXCJwYXRoXCI/YWRiMCIsIndlYnBhY2s6Ly9wYy1jb21wYXQvZXh0ZXJuYWwgY29tbW9uanMgXCJpbnNwZWN0b3JcIj85N2E0Iiwid2VicGFjazovL3BjLWNvbXBhdC8uL3NyYy9tYWluL2RlYnVnLnRzP2IxOTAiLCJ3ZWJwYWNrOi8vcGMtY29tcGF0L2V4dGVybmFsIGNvbW1vbmpzIFwic3VjcmFzZVwiPzJkYWIiLCJ3ZWJwYWNrOi8vcGMtY29tcGF0L2V4dGVybmFsIGNvbW1vbmpzIFwic2Fzc1wiP2IwZmQiLCJ3ZWJwYWNrOi8vcGMtY29tcGF0Ly4vc3JjL2NvbW1vbi9pcGNldmVudHMudHM/ZTI3OSIsIndlYnBhY2s6Ly9wYy1jb21wYXQvZXh0ZXJuYWwgY29tbW9uanMgXCJmc1wiPzUwZjIiLCJ3ZWJwYWNrOi8vcGMtY29tcGF0Ly4vc3JjL21haW4vZXZlbnRzLnRzP2Q1YjMiLCJ3ZWJwYWNrOi8vcGMtY29tcGF0Ly4vc3JjL21haW4vaW5pdFJlbW90ZS50cz9mM2U1Iiwid2VicGFjazovL3BjLWNvbXBhdC8uL3NyYy9tYWluL2luZGV4LnRzPzA1YjYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgX19XRUJQQUNLX05BTUVTUEFDRV9PQkpFQ1RfXyA9IHJlcXVpcmUoXCJtb2R1bGVcIik7IiwiY29uc3QgX19XRUJQQUNLX05BTUVTUEFDRV9PQkpFQ1RfXyA9IHJlcXVpcmUoXCJwYXRoXCIpOyIsImNvbnN0IF9fV0VCUEFDS19OQU1FU1BBQ0VfT0JKRUNUX18gPSByZXF1aXJlKFwiaW5zcGVjdG9yXCIpOyIsImltcG9ydCB7d2FpdEZvckRlYnVnZ2VyLCBvcGVufSBmcm9tIFwiaW5zcGVjdG9yXCI7XHJcblxyXG5pZiAocHJvY2Vzcy5hcmd2LmpvaW4oXCJcIikuaW5jbHVkZXMoXCItLWRlYnVnXCIpKSB7XHJcbiAgICBvcGVuKCk7XHJcbiAgICB3YWl0Rm9yRGVidWdnZXIoKTtcclxufSIsImNvbnN0IF9fV0VCUEFDS19OQU1FU1BBQ0VfT0JKRUNUX18gPSByZXF1aXJlKFwic3VjcmFzZVwiKTsiLCJjb25zdCBfX1dFQlBBQ0tfTkFNRVNQQUNFX09CSkVDVF9fID0gcmVxdWlyZShcInNhc3NcIik7IiwiLy8gTWFpblxyXG5leHBvcnQgY29uc3QgTUFJTl9FVkVOVCA9IFwicGNjb21wYXQtbWFpbi1ldmVudFwiO1xyXG5leHBvcnQgY29uc3QgQ09NUElMRV9TQVNTID0gXCJwY2NvbXBhdC1jb21waWxlLXNhc3NcIjtcclxuZXhwb3J0IGNvbnN0IENPTVBJTEVfSlNYID0gXCJwY2NvbXBhdC1jb21waWxlLWpzeFwiO1xyXG5leHBvcnQgY29uc3QgR0VUX0FQUF9QQVRIID0gXCJwY2NvbXBhdC1nZXQtYXBwLXBhdGhcIjtcclxuZXhwb3J0IGNvbnN0IFNFVF9ERVZfVE9PTFMgPSBcInBjY29tcGF0LW9wZW4tZGV2dG9vbHNcIjtcclxuZXhwb3J0IGNvbnN0IEdFVF9XSU5ET1dfREFUQSA9IFwicGNjb21wYXQtZ2V0LXdpbmRvdy1kYXRhXCI7XHJcblxyXG4vLyBQcmVsb2FkXHJcbmV4cG9ydCBjb25zdCBFWFBPU0VfUFJPQ0VTU19HTE9CQUwgPSBcInBjY29tcGF0LWV4cG9zZS1wcm9jZXNzLWdsb2JhbFwiO1xyXG5leHBvcnQgY29uc3QgSEFORExFX0NBTExCQUNLID0gXCJwY2NvbXBhdC1oYW5kbGUtY2FsbGJhY2tcIjsiLCJjb25zdCBfX1dFQlBBQ0tfTkFNRVNQQUNFX09CSkVDVF9fID0gcmVxdWlyZShcImZzXCIpOyIsImltcG9ydCBzdWNyYXNlIGZyb20gXCJzdWNyYXNlXCI7XHJcbmltcG9ydCBzYXNzIGZyb20gXCJzYXNzXCI7XHJcbmltcG9ydCB7aXBjTWFpbiwgYXBwLCBCcm93c2VyV2luZG93fSBmcm9tIFwiZWxlY3Ryb25cIjtcclxuaW1wb3J0ICogYXMgSVBDRXZlbnRzIGZyb20gXCIuLi9jb21tb24vaXBjZXZlbnRzXCI7XHJcbmltcG9ydCBmcyBmcm9tIFwiZnNcIjtcclxuXHJcbmlwY01haW4ub24oSVBDRXZlbnRzLkdFVF9BUFBfUEFUSCwgKGV2ZW50KSA9PiB7XHJcbiAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGFwcC5nZXRBcHBQYXRoKCk7XHJcbn0pO1xyXG5cclxuaXBjTWFpbi5vbihJUENFdmVudHMuR0VUX1dJTkRPV19EQVRBLCAoZXZlbnQpID0+IHtcclxuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQuc2VuZGVyLmtlcm5lbFdpbmRvd0RhdGE7XHJcbn0pO1xyXG5cclxuaXBjTWFpbi5vbihJUENFdmVudHMuQ09NUElMRV9TQVNTLCAoZXZlbnQsIGZpbGUpID0+IHtcclxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IGFiYyA9IHNhc3MucmVuZGVyU3luYyh7ZmlsZX0pO1xyXG4gICAgICAgIHJlc3VsdCA9IGFiYy5jc3MudG9TdHJpbmcoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSByZXN1bHQ7XHJcbn0pO1xyXG5cclxuaXBjTWFpbi5vbihJUENFdmVudHMuQ09NUElMRV9KU1gsIChldmVudCwgZmlsZSkgPT4ge1xyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGUpKSB7XHJcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBcIlwiO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmaWxlY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCBcInV0ZjhcIik7XHJcblxyXG4gICAgY29uc3Qge2NvZGV9ID0gc3VjcmFzZS50cmFuc2Zvcm0oZmlsZWNvbnRlbnQsIHtcclxuICAgICAgICB0cmFuc2Zvcm1zOiBbXCJqc3hcIiwgXCJpbXBvcnRzXCIsIFwidHlwZXNjcmlwdFwiXSxcclxuICAgICAgICBmaWxlUGF0aDogZmlsZVxyXG4gICAgfSk7XHJcblxyXG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSBjb2RlO1xyXG59KTtcclxuXHJcbmlwY01haW4uaGFuZGxlKElQQ0V2ZW50cy5TRVRfREVWX1RPT0xTLCAoZXZlbnQsIHZhbHVlOiBib29sZWFuKSA9PiB7XHJcbiAgICBjb25zdCB3aW4gPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xyXG5cclxuICAgIGlmICghd2luKSByZXR1cm47XHJcblxyXG4gICAgaWYgKHZhbHVlICYmICF3aW4ud2ViQ29udGVudHMuaXNEZXZUb29sc09wZW5lZCgpKSB7XHJcbiAgICAgICAgd2luLndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB3aW4ud2ViQ29udGVudHMuY2xvc2VEZXZUb29scygpO1xyXG4gICAgfVxyXG59KTsiLCJpbXBvcnQge2VuYWJsZSwgaW5pdGlhbGl6ZX0gZnJvbSBcIkBlbGVjdHJvbi9yZW1vdGUvbWFpblwiOyBcbmltcG9ydCB7QnJvd3NlcldpbmRvdywgYXBwfSBmcm9tIFwiZWxlY3Ryb25cIjtcblxuaW5pdGlhbGl6ZSgpO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlUmVtb3RlTW9kdWxlID0gZnVuY3Rpb24gKHdlYkNvbnRlbnRzOiBFbGVjdHJvbi5XZWJDb250ZW50cykge1xuICAgIGNvbnNvbGUubG9nKFwiW1Bvd2VyY29yZF0gRW5hYmxpbmcgcmVtb3RlIG1vZHVsZSBmb3JcIiwgd2ViQ29udGVudHMuaWQpO1xuXG4gICAgZW5hYmxlKHdlYkNvbnRlbnRzKTtcbn07XG5cbmZvciAoY29uc3Qge3dlYkNvbnRlbnRzfSBvZiBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKSkge1xuICAgIGVuYWJsZVJlbW90ZU1vZHVsZSh3ZWJDb250ZW50cyk7XG59XG5cbmFwcC5vbihcImJyb3dzZXItd2luZG93LWNyZWF0ZWRcIiwgKF8sIHt3ZWJDb250ZW50c30pID0+IHtcbiAgICBlbmFibGVSZW1vdGVNb2R1bGUod2ViQ29udGVudHMpO1xufSk7IiwiaW1wb3J0IE1vZHVsZSBmcm9tIFwibW9kdWxlXCI7XHJcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbk1vZHVsZS5nbG9iYWxQYXRocy5wdXNoKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi5cIiwgXCIuLlwiLCBcIm5vZGVfbW9kdWxlc1wiKSk7XHJcblxyXG5pbXBvcnQgXCIuL2RlYnVnXCI7XHJcbmltcG9ydCBcIi4vZXZlbnRzXCI7XHJcbmltcG9ydCBcIi4vaW5pdFJlbW90ZVwiOyJdLCJuYW1lcyI6WyJ3YWl0Rm9yRGVidWdnZXIiLCJvcGVuIiwicHJvY2VzcyIsImFyZ3YiLCJqb2luIiwiaW5jbHVkZXMiLCJNQUlOX0VWRU5UIiwiQ09NUElMRV9TQVNTIiwiQ09NUElMRV9KU1giLCJHRVRfQVBQX1BBVEgiLCJTRVRfREVWX1RPT0xTIiwiR0VUX1dJTkRPV19EQVRBIiwiRVhQT1NFX1BST0NFU1NfR0xPQkFMIiwiSEFORExFX0NBTExCQUNLIiwic3VjcmFzZSIsInNhc3MiLCJpcGNNYWluIiwiYXBwIiwiQnJvd3NlcldpbmRvdyIsIklQQ0V2ZW50cyIsImZzIiwib24iLCJldmVudCIsInJldHVyblZhbHVlIiwiZ2V0QXBwUGF0aCIsInNlbmRlciIsImtlcm5lbFdpbmRvd0RhdGEiLCJmaWxlIiwicmVzdWx0IiwiYWJjIiwicmVuZGVyU3luYyIsImNzcyIsInRvU3RyaW5nIiwiZXJyb3IiLCJjb25zb2xlIiwiZXhpc3RzU3luYyIsImZpbGVjb250ZW50IiwicmVhZEZpbGVTeW5jIiwiY29kZSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybXMiLCJmaWxlUGF0aCIsImhhbmRsZSIsInZhbHVlIiwid2luIiwiZnJvbVdlYkNvbnRlbnRzIiwid2ViQ29udGVudHMiLCJpc0RldlRvb2xzT3BlbmVkIiwib3BlbkRldlRvb2xzIiwiY2xvc2VEZXZUb29scyIsImVuYWJsZSIsImluaXRpYWxpemUiLCJlbmFibGVSZW1vdGVNb2R1bGUiLCJsb2ciLCJpZCIsImdldEFsbFdpbmRvd3MiLCJfIiwiTW9kdWxlIiwicGF0aCIsImdsb2JhbFBhdGhzIiwicHVzaCIsInJlc29sdmUiLCJfX2Rpcm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///469\n')},496:e=>{e.exports=require("electron")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var I=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(I.exports,I,I.exports,__webpack_require__),I.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var I in n)__webpack_require__.o(n,I)&&!__webpack_require__.o(e,I)&&Object.defineProperty(e,I,{enumerable:!0,get:n[I]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(469),__webpack_export_target__=exports;for(var i in __webpack_exports__)__webpack_export_target__[i]=__webpack_exports__[i];__webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,"__esModule",{value:!0});